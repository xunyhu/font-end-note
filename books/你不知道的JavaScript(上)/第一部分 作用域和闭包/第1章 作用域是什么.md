# 第 1 章 作用域是什么

几乎所有编程语言最基本的功能之一，就是能够储存变量当中的值，并且能在之后对这个值进行访问或修改。事实上，正是这种储存和访问变量的值的能力将状态带给了程序。

但是将变量引入程序会引起几个很有意思的问题，也正是我们将要讨论的：这些变量住在哪里？换句话说，它们储存在哪里？最重要的是，程序需要时如何找到它们？

这些问题说明需要`一套设计良好的规则来存储变量，并且之后可以方便地找到这些变量。这套规则被称为作用域`。

## 1.1 编译原理

JavaScript 引擎进行编译的步骤和传统的编译语言非常相似，在某些环节可能比预想的要复杂。在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”​。

1. 分词/词法分析（Tokenizing/Lexing）

   这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）​。例如，考虑程序 var a = 2;。这段程序通常会被分解成为下面这些词法单元：var、a、=、2 、;。空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。

2. 解析/语法分析（Parsing）

   这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。`这个树被称为“抽象语法树”​（Abstract Syntax Tree, AST）`​。

3. 代码生成

   `将 AST 转换为可执行代码`的过程被称为代码生成。这个过程与语言、目标平台等息息相关。

## 1.2 理解作用域

我们学习作用域的方式是将这个过程模拟成几个人物之间的对话。那么，由谁进行这场对话呢？

### 1.2.1 演员表

- 引擎

  从头到尾负责整个 JavaScript `程序的编译及执行`过程。

- 编译器

  引擎的好朋友之一，负责`语法分析及代码生成`等脏活累活。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。

- 作用域

  引擎的另一位好朋友，`负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限`。作用域是根据名称查找变量的一套规则。

### 1.2.2 对话

下面我们将 var a = 2；分解，看看引擎和它的朋友们是如何协同工作的。

变量的赋值操作会执行两个动作，`首先`编译器会在当前作用域中声明一个变量（如果之前没有声明过）​，`然后`在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。

### 1.2.3 编译器有话说

引擎执行编译代码时，会通过查找变量 a 来判断它是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。

当变量出现在赋值操作的左侧时进行 `LHS 查询`，出现在右侧时进行 `RHS 查询`。RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其赋值。

### 1.2.4 引擎和作用域的对话

### 1.2.5 小测验

```js
function foo(a) {
  var b = a;
  return a + b;
}
var c = foo(2);
```

1.  找到其中所有的 LHS 查询。​（这里有 3 处！）

    - var c = foo(2); foo(a); 隐式的 a=2 操作, 为了给参数 a 分配值，需要进行一次 LHS 查询;
    - var b = a; 给 b 分配值，需要进行一次 LHS 查询;
    - return a + b; 隐式的操作定义了一个存储 a+b 结果的变量，给结果分配值，需要进行一次 LHS 查询
    - 参考答案：`c = ..;` 、a = 2（隐式变量分配）、b = ..

2.  找到其中所有的 RHS 查询。​（这里有 4 处！）

    - var c = foo(2); foo 进行一次 RHS 引用;
    - var b = a; 取 a 的值 进行一次 RHS 查询;
    - return a + b; 取 a 的值 进行一次 RHS 查询; 取 b 的值 进行一次 RHS 查询;
    - 参考答案： foo(2)、= a; 、a ..、.. b

## 1.3 作用域嵌套

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。

## 1.4 异常

为什么区分 LHS 和 RHS 是一件重要的事情？因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。

如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 `ReferenceError` 异常。

如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，`比如试图对一个非函数类型的值进行函数调用，或者引用 null 或 undefined 类型的值中的属性`，那么引擎会抛出另外一种类型的异常，叫作 `TypeError`。

相较之下，当引擎执行 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非“严格模式”下。

## 1.5 小结

1. 作用域是一套规则，用于确定在何处以及如何查找变量（标识符）​。如果查找的目的是`对变量进行赋值`，那么就会使用 LHS 查询；如果目的是`获取变量的值`，就会使用 RHS 查询。

2. JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声明会被分解成两个独立的步骤：

   1．首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。
   2．接下来，a = 2 会查询（LHS 查询）变量 a 并对其进行赋值。

3. LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符）​，就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼）​，最后抵达全局作用域（顶层）​，无论找到或没找到都将停止。
4. 不成功的 RHS 引用会导致抛出 ReferenceError 异常。ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。
