# 第 3 章 函数作用域和块作用域

## 3.1 函数中的作用域

函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）​。

## 3.2 隐藏内部实现

最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。

1. 全局命名空间

   当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴露在顶级的词法作用域中。

2. 模块管理

   另外一种避免冲突的办法和现代的模块机制很接近，就是从众多模块管理器中挑选一个来使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。

## 3.3 函数作用域

我们已经知道，在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。

### 3.3.1 匿名和具名

```js
setTimeout(function () {
  console.log("I waited 1 second! ");
}, 1000);
```

```js
setTimeout(function timeoutHandler() {
  // <-- 快看，我有名字了！
  console.log("I waited 1 second! ");
}, 1000);
```

### 3.3.2 立即执行函数表达式

这种模式很常见，几年前社区给它规定了一个术语：`IIFE`，代表立即执行函数表达式（Immediately Invoked Function Expression）​；

```js
var a = 2;
(function foo() {
  var a = 3;
  console.log(a); // 3
})();
console.log(a); // 2
```

## 3.4 块作用域

当使用 var 声明变量时，它写在哪里都是一样的，因为它们最终都会属于外部作用域。

```js
for (var i = 0; i < 10; i++) {
  console.log(i); //0 ~ 9
}
console.log(i); //10

var foo = true;
if (foo) {
  var bar = foo * 2;
  console.log(bar); //2
}
console.log(bar); //2
```

以上面的 for 循环为例，for 循环内部使用的变量 i 会污染到整个函数作用域中。  
变量 i 的块作用域（如果存在的话）将使得其只能在 for 循环内部使用，如果在函数中其他地方使用会导致错误。这对保证变量不会被混乱地复用及提升代码的可维护性都有很大帮助。

### 3.4.1 with

用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。

### 3.4.2 try/catch

非常少有人会注意到 JavaScript 的 ES3 规范中规定 try/catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。例如：

```js
try {
  undefined(); // 执行一个非法操作来强制制造一个异常
} catch (err) {
  console.log(err); // 能够正常执行！
}

console.log(err); // ReferenceError: err not found
```

### 3.4.3 let

ES6 改变了现状，引入了新的 let 关键字，提供了除 var 以外的另一种变量声明方式。

```js
var foo = true;

if (foo) {
    let bar = foo ＊ 2;
    bar = something(bar);
    console.log(bar);
}

console.log(bar); // ReferenceError
```

但是使用 let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在”​。

```js
{
  console.log(bar); // ReferenceError!
  let bar = 2;
}
```

1. 垃圾收集

   块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关。

2. let 循环

   一个 let 可以发挥优势的典型例子就是之前讨论的 for 循环。

   ```js
   for (let i = 0; i < 10; i++) {
     console.log(i);
   }

   console.log(i); // ReferenceError
   ```

### 3.4.4 const

除了 let 以外，ES6 还引入了 const，同样可以用来创建块作用域变量，但其值是固定的（常量）​。之后任何试图修改值的操作都会引起错误。

```js
var foo = true;

if (foo) {
  var a = 2;
  const b = 3; // 包含在if中的块作用域常量

  a = 3; // 正常！
  b = 4; // 错误！
}

console.log(a); // 3
console.log(b); // ReferenceError!
```

## 3.5 小结

函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。

但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指{ .. }内部）​。

从 ES3 开始，try/catch 结构在 catch 分句中具有块作用域。

在 ES6 中引入了 let 关键字（var 关键字的表亲）​，用来在任意代码块中声明变量。if (..) { let a = 2; }会声明一个劫持了 if 的{ .. }块的变量，并且将变量添加到这个块中。

有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用何种作用域，创造可读、可维护的优良代码。
