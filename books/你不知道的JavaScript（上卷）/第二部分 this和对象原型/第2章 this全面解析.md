# 第 2 章 this 全面解析

在第 1 章中，我们排除了一些对于 this 的错误理解并且明白了每个函数的 this 是在调用时被绑定的，完全取决于函数的调用位置（也就是函数的调用方法）​。

## 2.1 调用位置

在理解 this 的绑定过程之前，首先要理解调用位置：调用位置就是函数在代码中被调用的位置（而不是声明的位置）​。只有仔细分析调用位置才能回答这个问题：这个 this 到底引用的是什么？

## 2.2 绑定规则

### 2.2.1 默认绑定

### 2.2.2 隐式绑定

### 2.2.3 显式绑定

### 2.2.4 new 绑定

## 2.3 优先级

## 2.4 绑定例外

### 2.4.1 被忽略的 this

### 2.4.2 间接引用

### 2.4.3 软绑定

## 2.5 this 词法

## 2.6 小结

如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断 this 的绑定对象。

1. 由 new 调用？绑定到新创建的对象。
2. 由 call 或者 apply（或者 bind）调用？绑定到指定的对象。
3. 由上下文对象调用？绑定到那个上下文对象。
4. 默认：在严格模式下绑定到 undefined，否则绑定到全局对象。

一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑定，你可以使用一个 DMZ 对象，比如 ø = Object.create(null)，以保护全局对象。

ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）​。这其实和 ES6 之前代码中的 self = this 机制一样。
