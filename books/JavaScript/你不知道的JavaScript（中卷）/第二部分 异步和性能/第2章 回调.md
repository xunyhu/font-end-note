# 第 2 章 回调

在第 1 章里，我们探讨了与 JavaScript 异步编程相关的概念和术语。我们的关注点是`理解处理所有事件（异步函数调用）的单线程（一次一个）事件循环队列`。我们还介绍了多个并发模式以不同的方式解释同时运行的`事件链或“进程”`​（任务、函数调用，等等）之间的关系（如果有的话！）​。

但是……回调函数也不是没有缺点。很多开发者因为更好的异步模式 promise（promise 也是“承诺、希望”的意思，此处一语双关）而激动不已。但是，只有理解了某种抽象的目标和原理，才能有效地应用这种抽象机制。

## 2.1 continuation

```js
// A
ajax( "..", function(..){
    // C
} );
// B
```

// A 和// B 表示程序的前半部分（也就是现在的部分）​，而// C 标识了程序的后半部分（也就是将来的部分）​。前半部分立刻执行，然后是一段时间不确定的停顿。在未来的某个时刻，如果 Ajax 调用完成，程序就会从停下的位置继续执行后半部分。

换句话说，`回调函数包裹或者说封装了程序的延续（continuation）`​。

## 2.2 顺序的大脑

### 2.2.1 执行与计划

### 2.2.2 嵌套回调与链式回调

```js
listen("click", function handler(evt) {
  setTimeout(function request() {
    ajax("http://some.url.1", function response(text) {
      if (text == "hello") {
        handler();
      } else if (text == "world") {
        request();
      }
    });
  }, 500);
});
```

这种代码常常被称为回调地狱（callback hell）​，有时也被称为毁灭金字塔（pyramid of doom，得名于嵌套缩进产生的横向三角形状）​。

## 2.3 信任问题

### 2.3.1 五个回调的故事

### 2.3.2 不只是别人的代码

## 2.4 尝试挽救回调

## 2.5 小结

回调函数是 JavaScript 异步的基本单元。但是随着 JavaScript 越来越成熟，对于异步编程领域的发展，回调已经不够用了。

第一，大脑对于事情的计划方式是线性的、阻塞的、单线程的语义，但是回调表达异步流程的方式是非线性的、非顺序的，这使得正确推导这样的代码难度很大。难于理解的代码是坏代码，会导致坏 bug。

我们需要一种更同步、更顺序、更阻塞的的方式来表达异步，就像我们的大脑一样。

第二，也是更重要的一点，回调会受到控制反转的影响，因为回调暗中把控制权交给第三方（通常是不受你控制的第三方工具！）来调用你代码中的 continuation。这种控制转移导致一系列麻烦的信任问题，比如回调被调用的次数是否会超出预期。

可以发明一些特定逻辑来解决这些信任问题，但是其难度高于应有的水平，可能会产生更笨重、更难维护的代码，并且缺少足够的保护，其中的损害要直到你受到 bug 的影响才会被发现。

我们需要一个通用的方案来解决这些信任问题。不管我们创建多少回调，这一方案都应可以复用，且没有重复代码的开销。

我们需要比回调更好的机制。到目前为止，回调提供了很好的服务，但是未来的 JavaScript 需要更高级、功能更强大的异步模式。本书接下来的几章会深入探讨这些新型技术。
