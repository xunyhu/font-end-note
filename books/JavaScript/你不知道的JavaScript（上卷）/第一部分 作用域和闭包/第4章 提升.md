# 第 4 章 提升

函数作用域和块作用域的行为是一样的，可以总结为：任何声明在某个作用域内的变量，都将附属于这个作用域。但是作用域同其中的变量声明出现的位置有某种微妙的联系，而这个细节正是我们将要讨论的内容。

## 4.1 先有鸡还是先有蛋

直觉上会认为 JavaScript 代码在执行时是由上到下一行一行执行的。但实际上这并不完全正确，有一种特殊情况会导致这个假设是错误的。

```js
a = 2;

var a;

console.log(a); // 2
```

考虑另外一段代码：

```js
console.log(a);

var a = 2;
```

鉴于上一个代码片段所表现出来的某种非自上而下的行为特点，你可能会认为这个代码片段也会有同样的行为而输出 2。  
还有人可能会认为，由于变量 a 在使用前没有先进行声明，因此会抛出 ReferenceError 异常。  
不幸的是两种猜测都是不对的。输出来的会是 undefined。那么到底发生了什么？看起来我们面对的是一个先有鸡还是先有蛋的问题。到底是声明（蛋）在前，还是赋值（鸡）在前？

## 4.2 编译器再度来袭

当你看到 var a = 2；时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成两个声明：var a；和 a = 2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。

我们的第一个代码片段会以如下形式进行处理：其中第一部分是编译，而第二部分是执行。

```js
var a;

a = 2;

console.log(a);
```

类似地，我们的第二个代码片段实际是按照以下流程处理的：

```js
var a;

console.log(a);

a = 2;
```

变量和函数声明从它们在代码中出现的位置被“移动”到了最上面。这个过程就叫作提升。换句话说，先有蛋（声明）后有鸡（赋值）。

函数声明会被提升，但是函数表达式却不会被提升。同时也要记住，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用：

```js
foo(); // TypeError
bar(); // ReferenceError

var foo = function bar() {
  // ...
};
```

这个代码片段经过提升后，实际上会被理解为以下形式：

```js
var foo;

foo(); // TypeError
bar(); // ReferenceError

foo = function() {
    var bar = ...self...
    // ...
}
```

## 4.3 函数优先

函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。

## 4.4 小结

我们习惯将 var a = 2；看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a 和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。

这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。

声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。

要注意避免重复声明，特别是当普通的 var 声明和函数声明混合在一起的时候，否则会引起很多危险的问题！
